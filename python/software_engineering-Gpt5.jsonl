{"query": "What is version control?", "context": "Software development teams need ways to track changes to code and collaborate effectively on projects.", "ground_truth": "A system that tracks changes to files over time", "response": "Version control is a system for tracking changes to files over time so you can revisit earlier states, collaborate safely, and understand who changed what and why. It's most commonly used for source code, but it also works for documents, configuration, data, and design assets.\n\nKey ideas:\n- Repository: A database of your files plus their history.\n- Commit: A snapshot of your changes, recorded with a message, author, and timestamp.\n- Diff: The set of changes between two versions.\n- Branch: A parallel line of development used to isolate work (features, experiments, fixes).\n- Merge: Combining changes from one branch into another; may require resolving conflicts.\n- Tag/Release: A named point in history (e.g., v1.2.0) often used for publishing stable versions.\n- Remote: A copy of the repository on another machine or service (e.g., GitHub, GitLab).\n\nWhy it's useful:\n- History and rollback: Revert to a known-good state if something breaks.\n- Collaboration: Multiple people can work simultaneously without overwriting each other.\n- Traceability: See who changed what, when, and why (audit trail).\n- Experimentation: Try ideas in branches without risking main code.\n- Backup and synchronization: Keep copies across machines and services.\n\nTypes of systems:\n- Centralized (one main server): Subversion (SVN), Perforce.\n- Distributed (each copy is a full history): Git, Mercurial. Git is the most widely used today.\n\nTypical workflow with Git:\n- Clone a repository from a remote.\n- Create a branch for your work.\n- Edit files, stage and commit changes with descriptive messages.\n- Push your branch to the remote.\n- Open a pull/merge request for review.\n- Merge after tests and review pass; resolve any conflicts if needed.\n- Tag a release when ready.\n\nBest practices:\n- Commit small, logical changes with clear messages.\n- Use branches for features and fixes; keep main branch stable.\n- Review changes via pull/merge requests.\n- Automate testing and checks on every commit (CI).\n- Ignore generated or large binary files; use Git LFS or specialized tools (e.g., DVC) for big data.\n\nVersion control is the backbone of modern collaborative development and a core part of reliable, reproducible workflows."}
{"query": "What does API stand for?", "context": "Modern software applications often need to communicate with other systems and services to exchange data.", "ground_truth": "Application Programming Interface", "response": "API stands for Application Programming Interface. It's a set of rules and tools that lets different software programs communicate with each other. (In other contexts, API can also mean American Petroleum Institute or Active Pharmaceutical Ingredient, but in tech it's usually Application Programming Interface.)"}
{"query": "What is the difference between compiled and interpreted languages?", "context": "Programming languages can be executed in different ways, affecting performance and portability.", "ground_truth": "Compiled languages are translated to machine code before execution, interpreted languages are executed line by line", "response": ""}
{"query": "What is continuous integration?", "context": "DevOps practices help teams automate testing and deployment to deliver software more reliably.", "ground_truth": "Automatically building and testing code changes frequently", "response": ""}
{"query": "What is a REST API?", "context": "Web services use standardized architectural patterns to enable communication between different applications.", "ground_truth": "An API that follows REpresentational State Transfer principles", "response": "A REST API is a web service that follows the REST (Representational State Transfer) architectural style. It exposes \"resources\" (such as users, orders, articles) over HTTP and lets clients perform operations on those resources using standard HTTP methods.\n\nKey ideas:\n- Resources are identified by URLs (e.g., /users/123).\n- Uses HTTP methods to express actions:\n  - GET: read\n  - POST: create\n  - PUT/PATCH: update\n  - DELETE: delete\n- Stateless: each request contains all the info needed; the server doesn't store client session state.\n- Uses standard HTTP status codes (e.g., 200 OK, 201 Created, 204 No Content, 400 Bad Request, 404 Not Found).\n- Returns representations of resources, commonly JSON (sometimes XML).\n- Can leverage HTTP features like caching, content negotiation, and headers.\n\nExample:\n- GET /articles/42 -> 200 OK with a JSON body describing article 42.\n- POST /articles with a JSON body -> 201 Created and a Location header pointing to the new resource.\n\nBenefits include simplicity, scalability, and broad compatibility; it's an architectural style rather than a protocol, and is different from alternatives like SOAP or GraphQL."}
{"query": "What is the purpose of unit testing?", "context": "Software quality assurance requires testing at multiple levels to catch bugs early in development.", "ground_truth": "Testing individual components or functions in isolation", "response": "Unit testing verifies the smallest testable parts of code (like a function or method) in isolation to ensure they behave as intended. Its main purposes are:\n\n- Validate correctness: Confirm outputs, state changes, and exceptions for given inputs.\n- Catch bugs early: Fast, cheap tests find issues soon after code is written.\n- Prevent regressions: Automatically rerun tests to detect accidental breaks when code changes.\n- Enable safe refactoring: A reliable test suite acts as a safety net when improving or reorganizing code.\n- Document behavior: Tests serve as executable examples of how the code should work.\n- Improve design: Writing unit tests encourages modular, loosely coupled code and clearer interfaces.\n- Support CI/CD and TDD: Provide rapid feedback in pipelines and guide development by specifying desired behavior first.\n\nGood unit tests are isolated (use mocks/stubs for external dependencies), deterministic, fast, and focus on a single behavior including edge cases.\n\nWhat unit tests are not: They don't validate interactions between components (integration tests do), end-to-end user flows, performance, or security - those require other testing types."}
{"query": "What is agile methodology?", "context": "Software development methodologies provide frameworks for organizing work and delivering value iteratively.", "ground_truth": "An iterative approach to software development emphasizing flexibility and collaboration", "response": ""}
{"query": "What is a database index?", "context": "Database performance optimization involves structures that speed up data retrieval operations.", "ground_truth": "A data structure that improves the speed of data retrieval", "response": ""}
{"query": "What is Docker?", "context": "Containerization technologies help developers package applications with their dependencies for consistent deployment.", "ground_truth": "A platform for developing and running applications in containers", "response": "Docker is an open-source platform for building, packaging, distributing, and running applications in lightweight, portable containers.\n\nKey ideas:\n- Containers: Self-contained environments that bundle an app with its libraries and dependencies, while sharing the host's OS kernel. They start fast and use fewer resources than virtual machines.\n- Images: Read-only templates that define what's in a container. You create images from a Dockerfile.\n- Dockerfile: A script of instructions (base image, files, commands) used to build an image.\n- Docker Engine: The runtime (daemon and API) that builds and runs containers; accessed via the Docker CLI.\n- Registries: Repositories for storing and sharing images (e.g., Docker Hub, private registries).\n- Docker Compose: A tool to define and run multi-container applications using a simple YAML file.\n\nWhy it's used:\n- Portability: \"Build once, run anywhere\" across machines and clouds.\n- Consistency: Same environment for development, testing, and production.\n- Efficiency: Faster startup and lower overhead than VMs.\n- Scalability: Fits well with microservices and orchestration tools like Kubernetes.\n- CI/CD: Simplifies packaging and deployment in automated pipelines.\n\nTypical workflow:\n- Write a Dockerfile\n- docker build -t myapp .\n- docker run -p 8080:80 myapp\n- Push/pull images to/from a registry\n\nHow it differs from virtual machines:\n- VMs include a full guest OS per instance; containers share the host kernel, making them smaller and faster but with less isolation than VMs."}
{"query": "What is the Big O notation used for?", "context": "Algorithm efficiency analysis helps developers understand performance characteristics of their code.", "ground_truth": "Describing the time or space complexity of algorithms", "response": "Big O notation is used to describe how the running time or memory usage of an algorithm grows as the input size increases. It gives an asymptotic upper bound on this growth, ignoring constant factors and lower-order terms, so you can compare the scalability of algorithms independent of hardware or implementation details.\n\nCommon uses:\n- Express time complexity (e.g., O(n), O(n log n), O(n^2))\n- Express space complexity (memory usage growth)\n- Compare algorithms' scalability and choose appropriate strategies\n- Communicate worst-case behavior; sometimes also used for average/best cases, but strictly it denotes an upper bound\n\nIt doesn't tell you exact runtimes; it characterizes growth rates as input size n becomes large."}
